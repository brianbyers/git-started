# This script is intended to be sourced when the current
# directory is the top level directory of the repository.

# Directories to ignore for ctags, etags, pretty printing, lint checking
# Include trailing slash
IGNORE_DIRS="3rd_party/ node_modules/ vendor/"

# Show messages in pretty colors.  Change or remove colors here.
COLOR_LINT_ERROR="\e[1;31m" # Bright red
COLOR_LINT_FILENAME="\e[1;33m" # Bright yellow
COLOR_PRETTY_FILENAME="\e[1;33m" # Bright yellow
COLOR_PRETTY_MESSAGE="\e[32m" # Green
COLOR_RESET="\e[m" # Reset

# Lint and pretty printer programs to use, by language.
# The list is a series of programs that are tried (see util/helpers/lint.d
# and util/helpers/pretty_print.d) in order until one script detects
# an available program and then it is used for the task.
# To run programs XX, then falling back to YY when XX is not available, use
# LINT_LANG="XX YY"
# To run XX and also run YY if both are available, falling back to XX
# and then falling back further to YY, use
# LINT_LANG="XX+YY XX YY"
# To completely disable
# LINT_LANG=""
LINT_JS="jslint jsl"
LINT_PHP="cli"

# Lint command-line options for various language/program pairs
LINT_JS_JSL_OPTIONS="-nologo -nofilelisting -nosummary -process"
LINT_JS_JSLINT_OPTIONS=""
LINT_PHP_CLI_OPTIONS="-d error_reporting=E_ALL -d display_errors=0"

# Provide the ability to override the above config with your own values
if [ -f util/config ]; then
	. util/config
fi

# Clear the current line
function echo_clear_line() {
	printf "\e[G\e[K"
}

# Allow escape codes
function echo_escape {
	printf "%b\n" "$1"
}

# Echo a prompt without a newline
function echo_prompt() {
	printf "%s" "$1"
}

# Echos out the file processing "submodule" or the file type for the given
# incoming file
function get_file_type() {
	local TYPE="$(run_all_scripts util/helpers/file_detection.d "$1")"
	
	if [ -z "$TYPE" ]; then
		# Failed to detect the type
		echo "unknown"
		return 1
	fi

	echo "$TYPE"
	return 0;
}

# Get the extension of a filename
# Needs to work with "file.txt" and return "txt", "no_extension" returns ""
# and "some.dir.name/some/path.name.here" shows "here"
# This does not use subshells
function file_extension() {
	local FN="${1##*/}" # Remove path, which might have periods
	local BASE="${FN%.*}" # Remove extension, file may have lots.of.periods or none
	echo "${FN:${#BASE}+1}"
}

# Resolve paths to a directory
# Echos the result with quotes
# Usage:  OLD_DIR="$(pwd)"
#         cd "$(dirname "$0")"/../..
#         . util/bin/bare_repo_setup
#         FILES="$(resolve_paths "$OLD_DIR" ${1+"$@"})"
# ParameterS:  DirectoryFromWhence FilenameOrPath
function resolve_path() {
	local WHENCE="$1" # Directory that we use for resolution
	local FILE="$2" # Relative or absolute file/path

	if [ "${FILE:0:1}" == "/" ]; then
		echo "$FILE"
	else
		echo "${WHENCE}/${FILE}"
	fi
}

# Run all scripts in the given subdirectory, like the run-parts command.
# Exit on error
# Parameters:  DirectoryOfScripts ArgsToPassToScripts
function run_all_scripts() {
	local RESULT
	local DIR="$1"
	shift

	if [ ! -d "$DIR" ]; then
		# No directory, thus no scripts to run, thus success!
		return 0
	fi

	for FN in "$DIR"/*; do
		# Run in subshell so we preserve environment.  Keep current environment
		# variables around for things like the pre-commit hook.
		(
			. "$FN" ${1+"$@"}
		)

		# Stop if any script reported an error
		RESULT=$?

		if [ $RESULT -ne 0 ]; then
			return $RESULT
		fi
	done

	return 0
}

# Run all helper scripts that match the settings
# Parameters: VariablePrefix HelperDirectoryBase Filename
function run_helpers() {
	local PREFIX="$1" # Prefix for variable to use for programs
	local HELPER_DIR="$2" # Name of directory in helpers.d
	local FILE="$3" # Filename to check or run against
	local FILE_TYPE="$(get_file_type "$FILE")"
	local CONFIGS="${PREFIX}_${FILE_TYPE^^}"
	eval "CONFIGS=\$$CONFIGS"
	local CONFIGSCONFIG COMMAND CONFIG_COMMANDS MISSING_COMMANDS RESULT

	HELPER_DIR="util/helpers/${HELPER_DIR}/${FILE_TYPE}"

	if [ ! -d "${HELPER_DIR}" ]; then
		# No scripts, thus nothing happens.  Don't report an error
		return 0
	fi

	if [ -z "$CONFIGS" ]; then
		# No configuration - skip validation
		return 0
	fi

	# Find a configuration that works
	for CONFIG in $CONFIGS; do
		CONFIG_COMMANDS="${CONFIG//+/ /}"
		MISSING_COMMANDS=""
		for COMMAND in $CONFIG_COMMANDS; do
			COMMAND="${HELPER_DIR}/${COMMAND}"
			if [ ! -f "$COMMAND" ]; then
				MISSING_COMMANDS="$COMMAND"
			fi
		done
		if [ -z "$MISSING_COMMANDS" ]; then
			# We have every component - run the linters
			for COMMAND in $CONFIG_COMMANDS; do
				COMMAND="${HELPER_DIR}/${COMMAND}"

				# Run in subshell so we preserve environment.
				(
					. "$COMMAND" "$FILE"
				)

				# Stop if any script reported an error
				RESULT=$?

				if [ $RESULT -ne 0 ]; then
					return $RESULT
				fi
			done

			# Pass
			return 0
		fi
	done

	# No matches
	return 0
}


# Returns information about a file as a string
# Result:  MD5 SizeInBytes UserName:GroupName AccessMode FileType
function stat_file() {
	local FN="$1"
	md5sum "$FN" | cut -b 1-32 | tr -d "\n"
	/usr/bin/stat --format="%s %U:%G %A %F" "$FN"
}

# Create a temporary file and echo out the name
function temporary_file() {
	if test_for_program mktemp; then
		mktemp
		return 0
	fi
	
	if test_for_program gmktemp; then
		gmktemp
		return 0
	fi

	if test_for_program tempfile; then
		tempfile
		return 0
	fi

	FN=/tmp/$(date +%c%N|md5sum|cut -b 1-32)

	while [ -f $FN ]; do
		FN=/tmp/$(date +%c%N|md5sum|cut -b 1-32)
	done

	touch $FN
	echo $FN
}

# Attempt to see if a program is in the path and if it can be used.
# Returns true if the program is available.
function test_for_program() {
	local WHICH="$(which "$1" 2>&1)"

	# No error code
	if [ $? -eq 0 ]; then
		# A string was reported back
		if [ ! -z "$WHICH" ]; then
			# That string is a real filename
			if [ -f "$WHICH" ]; then
				return 0
			fi
		fi
	fi

	return 1
}
